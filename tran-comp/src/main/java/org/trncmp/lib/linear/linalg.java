// ====================================================================== BEGIN FILE =====
// **                                    L I N A L G                                    **
// =======================================================================================
// **                                                                                   **
// **  Copyright (c) 2018, Stephen W. Soliday                                           **
// **                      stephen.soliday@trncmp.org                                   **
// **                      http://research.trncmp.org                                   **
// **                                                                                   **
// **  -------------------------------------------------------------------------------  **
// **                                                                                   **
// **  This program is free software: you can redistribute it and/or modify it under    **
// **  the terms of the GNU General Public License as published by the Free Software    **
// **  Foundation, either version 3 of the License, or (at your option)                 **
// **  any later version.                                                               **
// **                                                                                   **
// **  This program is distributed in the hope that it will be useful, but WITHOUT      **
// **  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    **
// **  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.   **
// **                                                                                   **
// **  You should have received a copy of the GNU General Public License along with     **
// **  this program. If not, see <http://www.gnu.org/licenses/>.                        **
// **                                                                                   **
// ----- Modification History ------------------------------------------------------------
/**
 * @brief Provides the interface and methods for arbitrary linear algebra functions.
 * @file linalg.java
 *
 * @author Stephen W. Soliday
 * @date 2018-03-31
 */
// =======================================================================================

package org.trncmp.lib.linear;


// =======================================================================================
public class linalg {
  // -----------------------------------------------------------------------------------

  // =====================================================================================
  /** @brief First Axis Rotation.
   *  @param ang angle in radians.
   *  @return affine matrix.
   *
   *  Rotate points around the X-axis from positive Y to positive Z.
   */
  // -------------------------------------------------------------------------------------
  public static Mat3 rot1( double ang ) {
    // -----------------------------------------------------------------------------------
    double c = Math.cos( ang );
    double s = Math.sin( ang );
    Mat3 m = new Mat3();

    m.A[0][0] = 1.0;  m.A[0][1] = 0.0;  m.A[0][2] = 0.0;
    m.A[1][0] = 0.0;  m.A[1][1] =  c;   m.A[1][2] =  s;
    m.A[2][0] = 0.0;  m.A[2][1] = -s;   m.A[2][2] =  c;

    return m;
  }


  // =====================================================================================
  /** @brief Second Axis Rotation.
   *  @param ang angle in radians.
   *  @return affine matrix.
   *
   *  Rotate points around the Y-axis from positive Z to positive X.
   */
  // -------------------------------------------------------------------------------------
  public static Mat3 rot2( double ang ) {
    // -----------------------------------------------------------------------------------
    double c = Math.cos( ang );
    double s = Math.sin( ang );
    Mat3 m = new Mat3();

    m.A[0][0] =  c;   m.A[0][1] = 0.0;  m.A[0][2] = -s;
    m.A[1][0] = 0.0;  m.A[1][1] = 1.0;  m.A[1][2] = 0.0;
    m.A[2][0] =  s;   m.A[2][1] = 0.0;  m.A[2][2] =  c;

    return m;
  }


  // =====================================================================================
  /** @brief Third Axis Rotation.
   *  @param ang angle in radians.
   *  @return affine matrix.
   *
   *  Rotate points around the Z-axis from positive X to positive Y.
   */
  // -------------------------------------------------------------------------------------
  public static Mat3 rot3( double ang ) {
    // -----------------------------------------------------------------------------------
    double c = Math.cos( ang );
    double s = Math.sin( ang );
    Mat3 m = new Mat3();

    m.A[0][0] =  c;   m.A[0][1] =  s;   m.A[0][2] = 0.0;
    m.A[1][0] = -s;   m.A[1][1] =  c;   m.A[1][2] = 0.0;
    m.A[2][0] = 0.0;  m.A[2][1] = 0.0;  m.A[2][2] = 1.0;

    return m;
  }




  // =====================================================================================
  // -------------------------------------------------------------------------------------
  public static void dot( Mat2 c, Mat2 a, Mat2 b ) {
    // -----------------------------------------------------------------------------------

    c.A[0][0] = a.A[0][0]*b.A[0][0] + a.A[0][1]*b.A[1][0];
    c.A[0][1] = a.A[0][0]*b.A[0][1] + a.A[0][1]*b.A[1][1];
    
    c.A[1][0] = a.A[1][0]*b.A[0][0] + a.A[1][1]*b.A[1][0];
    c.A[1][1] = a.A[1][0]*b.A[0][1] + a.A[1][1]*b.A[1][1];
  }

  // =====================================================================================
  // -------------------------------------------------------------------------------------
  public static void dot( Mat3 c, Mat3 a, Mat3 b ) {
    // -----------------------------------------------------------------------------------

    c.A[0][0] = a.A[0][0]*b.A[0][0] + a.A[0][1]*b.A[1][0] + a.A[0][2]*b.A[2][0];
    c.A[0][1] = a.A[0][0]*b.A[0][1] + a.A[0][1]*b.A[1][1] + a.A[0][2]*b.A[2][1];
    c.A[0][2] = a.A[0][0]*b.A[0][2] + a.A[0][1]*b.A[1][2] + a.A[0][2]*b.A[2][2];

    c.A[1][0] = a.A[1][0]*b.A[0][0] + a.A[1][1]*b.A[1][0] + a.A[1][2]*b.A[2][0];
    c.A[1][1] = a.A[1][0]*b.A[0][1] + a.A[1][1]*b.A[1][1] + a.A[1][2]*b.A[2][1];
    c.A[1][2] = a.A[1][0]*b.A[0][2] + a.A[1][1]*b.A[1][2] + a.A[1][2]*b.A[2][2];

    c.A[2][0] = a.A[2][0]*b.A[0][0] + a.A[2][1]*b.A[1][0] + a.A[2][2]*b.A[2][0];
    c.A[2][1] = a.A[2][0]*b.A[0][1] + a.A[2][1]*b.A[1][1] + a.A[2][2]*b.A[2][1];
    c.A[2][2] = a.A[2][0]*b.A[0][2] + a.A[2][1]*b.A[1][2] + a.A[2][2]*b.A[2][2];

  }

  // =====================================================================================
  // -------------------------------------------------------------------------------------
  public static void dot( Mat4 c, Mat4 a, Mat4 b ) {
    // -----------------------------------------------------------------------------------

    c.A[0][0] = a.A[0][0]*b.A[0][0] + a.A[0][1]*b.A[1][0] + a.A[0][2]*b.A[2][0] + a.A[0][3]*b.A[3][0];
    c.A[0][1] = a.A[0][0]*b.A[0][1] + a.A[0][1]*b.A[1][1] + a.A[0][2]*b.A[2][1] + a.A[0][3]*b.A[3][1];
    c.A[0][2] = a.A[0][0]*b.A[0][2] + a.A[0][1]*b.A[1][2] + a.A[0][2]*b.A[2][2] + a.A[0][3]*b.A[3][2];
    c.A[0][3] = a.A[0][0]*b.A[0][3] + a.A[0][1]*b.A[1][3] + a.A[0][2]*b.A[2][3] + a.A[0][3]*b.A[3][3];


    c.A[1][0] = a.A[1][0]*b.A[0][0] + a.A[1][1]*b.A[1][0] + a.A[1][2]*b.A[2][0] + a.A[1][3]*b.A[3][0];
    c.A[1][1] = a.A[1][0]*b.A[0][1] + a.A[1][1]*b.A[1][1] + a.A[1][2]*b.A[2][1] + a.A[1][3]*b.A[3][1];
    c.A[1][2] = a.A[1][0]*b.A[0][2] + a.A[1][1]*b.A[1][2] + a.A[1][2]*b.A[2][2] + a.A[1][3]*b.A[3][2];
    c.A[1][3] = a.A[1][0]*b.A[0][3] + a.A[1][1]*b.A[1][3] + a.A[1][2]*b.A[2][3] + a.A[1][3]*b.A[3][3];


    c.A[2][0] = a.A[2][0]*b.A[0][0] + a.A[2][1]*b.A[1][0] + a.A[2][2]*b.A[2][0] + a.A[2][3]*b.A[3][0];
    c.A[2][1] = a.A[2][0]*b.A[0][1] + a.A[2][1]*b.A[1][1] + a.A[2][2]*b.A[2][1] + a.A[2][3]*b.A[3][1];
    c.A[2][2] = a.A[2][0]*b.A[0][2] + a.A[2][1]*b.A[1][2] + a.A[2][2]*b.A[2][2] + a.A[2][3]*b.A[3][2];
    c.A[2][3] = a.A[2][0]*b.A[0][3] + a.A[2][1]*b.A[1][3] + a.A[2][2]*b.A[2][3] + a.A[2][3]*b.A[3][3];


    c.A[3][0] = a.A[3][0]*b.A[0][0] + a.A[3][1]*b.A[1][0] + a.A[3][2]*b.A[2][0] + a.A[3][3]*b.A[3][0];
    c.A[3][1] = a.A[3][0]*b.A[0][1] + a.A[3][1]*b.A[1][1] + a.A[3][2]*b.A[2][1] + a.A[3][3]*b.A[3][1];
    c.A[3][2] = a.A[3][0]*b.A[0][2] + a.A[3][1]*b.A[1][2] + a.A[3][2]*b.A[2][2] + a.A[3][3]*b.A[3][2];
    c.A[3][3] = a.A[3][0]*b.A[0][3] + a.A[3][1]*b.A[1][3] + a.A[3][2]*b.A[2][3] + a.A[3][3]*b.A[3][3];

  }


  // =====================================================================================
  // -------------------------------------------------------------------------------------
  public static void dot( Matrix M, Matrix a, Matrix b ) {
    // -----------------------------------------------------------------------------------
    int nr = M.nr;
    int nc = M.nc;
    int nk = a.nc;
    for ( int r=0; r<nr; r++ ) {
      for ( int c=0; c<nc; c++ ) {
        double sum = 0.0e0;
        for ( int k=0; k<nk; k++ ) {
          sum += ( a.A[r][k] * b.A[k][c] );
        }
        M.A[r][c] = sum;
      }
    }
  }

  
  // =====================================================================================
  // -------------------------------------------------------------------------------------
  public static void dot( Vec2 V, Mat2 M, Vec2 A ) {
    // -----------------------------------------------------------------------------------
    V.x = M.A[0][0]*A.x + M.A[0][1]*A.y;
    V.y = M.A[1][0]*A.x + M.A[1][1]*A.y;
  }

  // =====================================================================================
  // -------------------------------------------------------------------------------------
  public static void dot( Vec3 V, Mat3 M, Vec3 A ) {
    // -----------------------------------------------------------------------------------
    V.x = M.A[0][0]*A.x + M.A[0][1]*A.y + M.A[0][2]*A.z;
    V.y = M.A[1][0]*A.x + M.A[1][1]*A.y + M.A[1][2]*A.z;
    V.z = M.A[2][0]*A.x + M.A[2][1]*A.y + M.A[2][2]*A.z;
  }

  // =====================================================================================
  // -------------------------------------------------------------------------------------
  public static void dot( Vec4 V, Mat4 M, Vec4 A ) {
    // -----------------------------------------------------------------------------------
    V.x = M.A[0][0]*A.x + M.A[0][1]*A.y + M.A[0][2]*A.z + M.A[0][3]*A.t;
    V.y = M.A[1][0]*A.x + M.A[1][1]*A.y + M.A[1][2]*A.z + M.A[1][3]*A.t;
    V.z = M.A[2][0]*A.x + M.A[2][1]*A.y + M.A[2][2]*A.z + M.A[2][3]*A.t;
    V.t = M.A[3][0]*A.x + M.A[3][1]*A.y + M.A[3][2]*A.z + M.A[3][3]*A.t;
  }

  // =====================================================================================
  // -------------------------------------------------------------------------------------
  public static void dot( Vec2 V, Vec2 A, Mat2 M ) {
    // -----------------------------------------------------------------------------------
    V.x = M.A[0][0]*A.x + M.A[1][0]*A.y;
    V.y = M.A[0][1]*A.x + M.A[1][1]*A.y;
  }

  // =====================================================================================
  // -------------------------------------------------------------------------------------
  public static void dot( Vec3 V, Vec3 A, Mat3 M ) {
    // -----------------------------------------------------------------------------------
    V.x = M.A[0][0]*A.x + M.A[1][0]*A.y + M.A[2][0]*A.z;
    V.y = M.A[0][1]*A.x + M.A[1][1]*A.y + M.A[2][1]*A.z;
    V.z = M.A[0][2]*A.x + M.A[1][2]*A.y + M.A[2][2]*A.z;
  }

  // =====================================================================================
  // -------------------------------------------------------------------------------------
  public static void dot( Vec4 V, Vec4 A, Mat4 M ) {
    // -----------------------------------------------------------------------------------
    V.x = M.A[0][0]*A.x + M.A[1][0]*A.y + M.A[2][0]*A.z + M.A[3][0]*A.t;
    V.y = M.A[0][1]*A.x + M.A[1][1]*A.y + M.A[2][1]*A.z + M.A[3][1]*A.t;
    V.z = M.A[0][2]*A.x + M.A[1][2]*A.y + M.A[2][2]*A.z + M.A[3][2]*A.t;
    V.t = M.A[0][3]*A.x + M.A[1][3]*A.y + M.A[2][3]*A.z + M.A[3][3]*A.t;
  }



  // =====================================================================================
  // -------------------------------------------------------------------------------------
  public static void dot( Vector V, Matrix M, Vector A ) {
    // -----------------------------------------------------------------------------------
    int nr = M.nr;
    int nc = M.nc;
    for ( int r=0; r<nr; r++ ) {
      double sum = 0.0e0;
      for ( int c=0; c<nc; c++ ) {
        sum += ( M.A[r][c] * A.x[c]);
      }
      V.x[r] = sum;
    }
  }


  // =====================================================================================
  // -------------------------------------------------------------------------------------
  public static void dot( Vector V, Vector A, Matrix M ) {
    // -----------------------------------------------------------------------------------
    int nr = M.nr;
    int nc = M.nc;
    for ( int c=0; c<nc; c++ ) {
      double sum = 0.0e0;
      for ( int r=0; r<nr; r++ ) {
        sum += ( A.x[r] * M.A[r][c] );
      }
      V.x[c] = sum;
    }
  }



  // =====================================================================================
  // -------------------------------------------------------------------------------------
  public static Matrix cholesky( Matrix a, double epsilon ) {
    // -----------------------------------------------------------------------------------
    int        m = a.nr;
    Matrix l = new Matrix(m,m);

    l.set(0.0e0);

    for(int i = 0; i<m; i++){
      for(int k = 0; k < (i+1); k++){
        double sum = 0;
        for(int j = 0; j < k; j++){
          if ( i==j) {
            sum += ( (l.A[i][j] + epsilon) * (l.A[k][j] + epsilon) );
          } else {
            sum += l.A[i][j] * l.A[k][j];
          }
        }
        if ( i==k ) {
          l.A[i][k] = Math.sqrt(a.A[i][i] + epsilon - sum);
        } else {
          l.A[i][k] = (1.0 / (l.A[k][k] + epsilon) * (a.A[i][k] - sum));
        }
      }
    }
    return l;
  }




  // ============================================================= s = <x-mu|P|x-mu> =====
  /** @brief Mahalonobis
   *  @param[in] x  reference to the data vector.
   *  @param[in] mu reference to the mean vector.
   *  @param[in] P  reference to the precision matrix.
   *  @return scalar square of the Mahalonobis distance metric.
   *
   *  This is the square of the Mahalnobis distance when x is data, mu is the mean,
   *  and S is the inverse covariance of the data.
   */
  // -------------------------------------------------------------------------------------
  public static double Mahalanobis( Vector x, Vector mu, Matrix S ) {
    // -----------------------------------------------------------------------------------
    double a = 0.0e0;
    int n = x.nx;
    for ( int i=0; i<n; i++ ) {
      double t = 0.0e0;
      for ( int j=0; j<n; j++ ) {
        t += ( S.A[i][j] * ( x.x[j] - mu.x[j] ) );
      }
      a += ( t * ( x.x[i] - mu.x[i] ) );
    }
    return a;
  }








  // =====================================================================================
  /** @brief Diagonal.
   *  @param M reference to a matrix.
   *  @param V reference to a vector.
   *
   *  Create a diagonal matrix from a vector.
   */
  // -------------------------------------------------------------------------------------
  public static void diagonal( Mat2 M, Vec2 V ) {
    // -------------------------------------------------------------------------------------
    M.A[0][0] = V.x;   M.A[0][1] = 0.0;
    M.A[1][0] = 0.0;   M.A[1][1] = V.y;
  }

  
  // =====================================================================================
  /** @brief Diagonal.
   *  @param M reference to a matrix.
   *  @param V reference to a vector.
   *
   *  Create a diagonal matrix from a vector.
   */
  // -------------------------------------------------------------------------------------
  public static void diagonal( Mat3 M, Vec3 V ) {
    // -------------------------------------------------------------------------------------
    M.A[0][0] = V.x;   M.A[0][1] = 0.0;    M.A[0][2] = 0.0;
    M.A[1][0] = 0.0;   M.A[1][1] = V.y;    M.A[1][2] = 0.0;
    M.A[2][0] = 0.0;   M.A[2][1] = 0.0;    M.A[2][2] = V.z;
  }

  
  // =====================================================================================
  /** @brief Diagonal.
   *  @param M reference to a matrix.
   *  @param V reference to a vector.
   *
   *  Create a diagonal matrix from a vector.
   */
  // -------------------------------------------------------------------------------------
  public static void diagonal( Mat4 M, Vec4 V ) {
    // -------------------------------------------------------------------------------------
    M.A[0][0] = V.x;   M.A[0][1] = 0.0;   M.A[0][2] = 0.0;   M.A[0][3] = 0.0; 
    M.A[1][0] = 0.0;   M.A[1][1] = V.y;   M.A[1][2] = 0.0;   M.A[1][3] = 0.0; 
    M.A[2][0] = 0.0;   M.A[2][1] = 0.0;   M.A[2][2] = V.z;   M.A[2][3] = 0.0;
    M.A[3][0] = 0.0;   M.A[3][1] = 0.0;   M.A[3][2] = 0.0;   M.A[3][3] = V.t;
  }








  // =====================================================================================
  /** @brief Diagonal.
   *  @param V reference to a vector.
   *  @param M reference to a matrix.
   *
   *  Create a vector from the diagonal of a matrix.
   */
  // -------------------------------------------------------------------------------------
  public static void diagonal( Vec2 V, Mat2 M ) {
    // -------------------------------------------------------------------------------------
    V.x = M.A[0][0];
    V.y = M.A[1][1];
  }


  // =====================================================================================
  /** @brief Diagonal.
   *  @param V reference to a vector.
   *  @param M reference to a matrix.
   *
   *  Create a vector from the diagonal of a matrix.
   */
  // -------------------------------------------------------------------------------------
  public static void diagonal( Vec3 V, Mat3 M ) {
    // -------------------------------------------------------------------------------------
    V.x = M.A[0][0];
    V.y = M.A[1][1];
    V.z = M.A[2][2];
  }


  // =====================================================================================
  /** @brief Diagonal.
   *  @param V reference to a vector.
   *  @param M reference to a matrix.
   *
   *  Create a vector from the diagonal of a matrix.
   */
  // -------------------------------------------------------------------------------------
  public static void diagonal( Vec4 V, Mat4 M ) {
    // -------------------------------------------------------------------------------------
    V.x = M.A[0][0];
    V.y = M.A[1][1];
    V.z = M.A[2][2];
    V.t = M.A[3][3];
  }








  // =====================================================================================
  /** @brief Diagonal.
   *  @param V reference to a vector.
   *  @return diagonal matrix.
   *
   *  Create a diagonal matrix from a vector.
   */
  // -------------------------------------------------------------------------------------
  public static Mat2 diagonal( Vec2 V ) {
    // -------------------------------------------------------------------------------------
    Mat2 M = new Mat2();
    diagonal( M, V );
    return M;
  }

  
  // =====================================================================================
  /** @brief Diagonal.
   *  @param V reference to a vector.
   *  @return diagonal matrix.
   *
   *  Create a diagonal matrix from a vector.
   */
  // -------------------------------------------------------------------------------------
  public static Mat3 diagonal( Vec3 V ) {
    // -------------------------------------------------------------------------------------
    Mat3 M = new Mat3();
    diagonal( M, V );
    return M;
  }

  
  // =====================================================================================
  /** @brief Diagonal.
   *  @param V reference to a vector.
   *  @return diagonal matrix.
   *
   *  Create a diagonal matrix from a vector.
   */
  // -------------------------------------------------------------------------------------
  public static Mat4 diagonal( Vec4 V ) {
    // -------------------------------------------------------------------------------------
    Mat4 M = new Mat4();
    diagonal( M, V );
    return M;
  }








  // =====================================================================================
  /** @brief Diagonal.
   *  @param M reference to a matrix.
   *  @return diagonal matrix.
   *
   *  Create a vector from the diagonal of a matrix.
   */
  // -------------------------------------------------------------------------------------
  public static Vec2 diagonal( Mat2 M ) {
    // -------------------------------------------------------------------------------------
    Vec2 V = new Vec2();
    diagonal( V, M );
    return V;
  }


  // =====================================================================================
  /** @brief Diagonal.
   *  @param M reference to a matrix.
   *  @return diagonal matrix.
   *
   *  Create a vector from the diagonal of a matrix.
   */
  // -------------------------------------------------------------------------------------
  public static Vec3 diagonal( Mat3 M ) {
    // -------------------------------------------------------------------------------------
    Vec3 V = new Vec3();
    diagonal( V, M );
    return V;
  }


  // =====================================================================================
  /** @brief Diagonal.
   *  @param M reference to a matrix.
   *  @return diagonal matrix.
   *
   *  Create a vector from the diagonal of a matrix.
   */
  // -------------------------------------------------------------------------------------
  public static Vec4 diagonal( Mat4 M ) {
    // -------------------------------------------------------------------------------------
    Vec4 V = new Vec4();
    diagonal( V, M );
    return V;
  }


}


// =======================================================================================
// **                                    L I N A L G                                    **
// ======================================================================== END FILE =====
